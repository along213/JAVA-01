### JVM
之前对于JVM的理解，只停留在认识上，生产环境偶然出现OOM，就知道，昂，内存溢出了，肯定是代码哪里写的不规范了，看看生产环境的日志，找到具体的接口，然后想办法减少对象的创建，然后依着自己的理解，压测一下，完事收工；
现在的话，知道了java字节码技术（通过字节码文件看看虚拟机对这些代码是如何执行，优化的），对象大小的计算（权衡对象大小的设计），类的生命周期（保证没用的对象能够被回收），类加载的时机（通过对象的使用方式减少内存的占用），还有类加载器（tomcat如何做到wabapps目录下多个项目之间互相隔离），JVM内存模型（线程之间协作及安全问题，堆内存溢出的原因，栈内存溢出的原因，JVM配置内存和实际占用相差很大的原因：直接内存）及解决方案，GC策略（各个GC策略的优劣，日志分析，适用场景，压测，调优等）

![avatar](https://github.com/along213/JAVA-01/blob/main/Week_15/IO.png)

### NIO
这个章节复习了SOCKET网络编程，自己实现了基本的IO模型，知道了操作系统对于selector，poll，epoll IO多路复用机制的实现（基于操作系统提供的接口对网络IO对性能进行进一步的提升），知道了netty诞生的原因（使用java提供的nio功能太过复杂，使用成本高，引入bug的几率太大，上层应用不应该接触到这些底层的网络传输协议等），（异步，事件驱动，基于NIO），及适用场景（服务端，客户端，TCP/UDP）；

### 多线程
这个章节复习了线程的基本使用，线程与进程的关系，知道了java线程和操作系统线程之间的关系（对于线程的创建销毁资源的成本高），CPU的基本架构，线程安全问题，synchronized的原理及局限性（不灵活），JUC的常用类用法及原理（原子类，锁，线程池，工具类，集合类），灵活的LOCK，加锁需要考虑的问题，线程间协作与通信；

### Spring
这个章节主要学习到了spring框架对于模块之间的设计思想，MVC分层模式帮助很多企业对与复杂业务的简化 扩展性 可维护性，面向切面编程，管理对象生命周期与对象装配，分离了业务代码与功能代码，也对重复代码进行了简化，我认为最核心的就是spring这个依赖注入框架，简化了基于接口而非实现编程的复杂度，极大地增加了系统的扩展性；

### Mysql
这章学习到了性能指标（吞吐量，延迟，容量），优化原则（没有量化就没有优化，28原则，脱离场景谈性能都是耍流氓），了解到了数据关系模型（ER图），常见的数据库（关系型，内存数据库，文件数据库，时序数据库，NoSQL，NewSQL），复习了数据库设计范式，知道了数据库的执行流程，执行引擎的应用场景，sql的执行顺序，索引原理（数据页，聚集索引，及索引层数与索引大小的关系及计算），Mysql配置优化及数据库设计优化；通过学习我还在公司给大家分享了数据类型的选择及快速导入数据的方式（各个方式分析对比），帮助同事们对于数据结构及数据库连接池有了新的理解；

### RPC和微服务
这章学习到了RPC的基本概念（远程过程调用，支持异构型分布式系统间的通信，像调用本地方法一样调用远程方法）原理（代理机制，本地代理存根stub，远程代理存根skeleton），及如何设计一个RPC框架（基于共享接口还是IDL？动态代理还是AOP？序列化用文本还是二进制？基于TCP还是HTTP?服务端如何查找实现类？），知道了RPC框架和分布式服务的区别，知道了为什么需要配置、注册、元数据中心，它们解决了什么问题，及服务集群化后出现的问题及解决方案；单体服务和微服务的应用场景，及系统改造方法论，拆分原则，扩展立方体，自动化，分布式事务及监控体系；

### 分布式缓存
这个章节学习了数据的分类，数据性质分类（静态数据，准静态数据，中间态数据，动态数据），使用频率分类（热数据，温数据，冷数据，冰数据），缓存的本质，缓存的加载时机（启动时全量缓存，懒加载-同步/异步）缓存的有效性和数据同步，使用不当带来的问题，及远程缓存出现的原因（并发，容量，失效），缓存策略（容量，过期策略和常见问题-/缓存穿透/缓存击穿/缓存雪崩）

### 分布式消息队列
消息队列出现的原因（系统间通信方式需要异步消息通信，简化依赖关系，在压力大时可缓冲，保障消息可靠甚至顺序），消息队列的优势（异步通信，通信可靠，系统解耦，削峰填谷），消息处理模式（PTP,PubSub），消息处理保障（QoS，事务，有序性，消息协议），消息队列的通用结构及开元中间件
